---
title: "Phylogeny and Species Trait Effects on Detectability"
author: "Peter Solymos"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Phylogeny and Species Trait Effects on Detectability}
output: knitr:::html_vignette
---

```{r update-stuff,eval=FALSE,results='hide',echo=FALSE}
devtools::install_github("borealbirds/lhreg")
#devtools::install_github("borealbirds/lhreg", ref="bootstrap")
devtools::build_vignettes("~/repos/lhreg")
```

## Introduction

This document is a supporting material for the manuscript entitled
*Phylogeny and species traits predict songbird detectability* by
Peter Solymos, Steven M. Matsuoka, Diana Stralberg, Erin M. Bayne, and Nicole K. S. Barker.

The **lhreg** R package contains the (1) data, (2) analysis code used in the manuscript,
and (3) code required to summarize the results and produce tables and figures.

The R package is hosted on [GitHub](https://github.com/borealbirds/lhreg),
Please submit issues [here](https://github.com/borealbirds/lhreg/issues).

The package is archived on Zenodo under the DOI [10.5281/zenodo.574886](https://zenodo.org/badge/latestdoi/90998177).

The package can be installed as:

```{r install,eval=FALSE}
devtools::install_github("borealbirds/lhreg")
```

The present document can be viewed as:

```{r vignette,eval=FALSE}
vignette(topic = "lhreg", package = "lhreg")
```

## Components of detectability

The manuscript refer to singing rate ($SR$, here we also refer to it as `phi`)
and detection distance ($DD$, which we refer to as `tau`),
which are linked to detectability as explained in this section.
Solymos et al. (2013, DOI [10.1111/2041-210X.12106](https://dx.doi.org/10.1111/2041-210X.12106))
describes the mathematical details of singing rate estimation based on
removal sampling and effective detection distance estimation via distance sampling.
These quantities define the probability of individuals of the species
are available for sampling given presence (often referred to as availability, $p$),
and the probability that an individual of that species is being detected given
it produces a cue (often referred to as perceptibility, $q$).

$p=1-exp(-t~SR)$, where $t$ is the duration of the counting period.
$q=DD^2~(1-exp(-r^2 / DD^2))~/~r^2$, where $r$ is the rounting radius (i.e. not
counting individuals beyond this distance from the observer).
Probability of detection is the produc to the two components: $pq$.

## Data and data processing

### Trait variables

The `lhreg_data` is a data frame with all response variables
(`logphi` is log singing rate, `logtau` is log detection distance)
and trait values (unmodified and transformed versions).

```{r trait-data,message=FALSE}
library(lhreg)
data(lhreg_data)
str(lhreg_data)
with(lhreg_data, plot(exp(logphi), exp(logtau),
    cex=logmass*0.5, col=Mig2, pch=c(21, 22)[Hab2]))
legend("topright", bty="n", pch=c(21, 21, 22, 22), col=c(1,2,1,2),
    legend=c("Migratory/Closed", "Resident/Closed",
    "Migratory/Open", "Resident/Open"))
```

### Phylogenetic correlations

This code was used to average the 1000 pseudo-posterior trees from Jetz et al.
(2012) with Ericson backbone to represent the phylogenetic relationships among the species:

```{r phylo-corr,eval=FALSE}
library(ape)
mph <- read.nexus("11960.tre") # 1000 trees with Ericson backbone
lhreg_tree <- consensus(mph)
table(sapply(mph, function(z) length(z$tip.label)))
CORR <- TRUE
vv <- list()
vv[[1]] <- vcv(mph[[1]], corr=CORR)
for (i in 2:length(mph)) {
    v <- vcv(mph[[i]], corr=CORR)
    v <- v[rownames(vv[[1]]), colnames(vv[[1]])]
    vv[[i]] <- v
}
vvv <- v
for (i in 1:length(v)) {
    vvv[i] <- mean(sapply(vv, function(z) z[i]))
}
spp <- intersect(rownames(lhreg_data), rownames(vvv))
vvv <- vvv[spp,spp]
cor_matrix <- as.matrix(nearPD(vvv, corr=TRUE)$mat)
```

The object `cor_matrix` is part of the **lhreg** package,
relative phylogenies can be reconstructed from it:

```{r heatmap}
library(ape)
data(cor_matrix)
data(lhreg_tree)
str(cor_matrix)
heatmap(cor_matrix)
```

```{r phylo-tree,fig.height=12,fig.width=7}
plot(compute.brlen(vcv2phylo(cor_matrix)), cex=0.5)
```

## Analysis

Linear model were used to screen trait variables, so that we compared
that *full* model with the intercept only *null* model, with or without
phylogenetic correlation.

### Variable screening for SR

```{r screening-sr}
library(lhreg)
data(lhreg_data)
data(cor_matrix)

y <- lhreg_data$logphi
m4 <- lm(y ~ logmass + Mig2 + Nesthm + xMaxFreqkHz + Hab4, lhreg_data)
m3 <- lm(y ~ logmass + Mig2 + Nesthm + xMaxFreqkHz + Hab3, lhreg_data)
m2 <- lm(y ~ logmass + Mig2 + Nesthm + xMaxFreqkHz + Hab2, lhreg_data)
m4s <- step(m4, trace=0)
m3s <- step(m3, trace=0)
m2s <- step(m2, trace=0)
AIC(m4,m3,m2,m4s,m3s,m2s)
summary(m2s)
mp <- update(m2s, .~.-Nesthm)

amp <- anova(mp)
round(structure(100 * amp[,"Sum Sq"] / sum(amp[,"Sum Sq"]),
    names=rownames(amp)), 1)

mp0 <- lm(y ~ 1)
summary(mp0) # null model for SR
summary(mp) # full model for SR
## evaluating interactions
mpx <- lm(y ~ logmass + Mig2 + Nesthm + xMaxFreqkHz + Hab2 +
    logmass:xMaxFreqkHz + Hab2:xMaxFreqkHz, lhreg_data)
mpx2 <- step(mpx)
summary(mpx2)
```

### Variable screening for DD

```{r screening-dd}
y <- lhreg_data$logtau
m4 <- lm(y ~ logmass + Mig2 + Nesthm + xMaxFreqkHz + Hab4, lhreg_data)
m3 <- lm(y ~ logmass + Mig2 + Nesthm + xMaxFreqkHz + Hab3, lhreg_data)
m2 <- lm(y ~ logmass + Mig2 + Nesthm + xMaxFreqkHz + Hab2, lhreg_data)
m4s <- step(m4, trace=0)
m3s <- step(m3, trace=0)
m2s <- step(m2, trace=0)
AIC(m4,m3,m2,m4s,m3s,m2s)
summary(m2s)
mt <- update(m2s, .~.-Nesthm)

amt <- anova(mt)
round(structure(100 * amt[,"Sum Sq"] / sum(amt[,"Sum Sq"]),
    names=rownames(amt)), 1)

mt0 <- lm(y ~ 1)
summary(mp0) # null model for DD
summary(mp) # full model for DD
## evaluating interactions
mtx <- lm(y ~ logmass + Mig2 + Nesthm + xMaxFreqkHz + Hab2 +
    logmass:xMaxFreqkHz + Hab2:xMaxFreqkHz, lhreg_data)
mtx2 <- step(mtx)
summary(mtx2)
```

### Mixed model selection

The following models were compared, the prefix `t` and `p`
indicates `tau` (detection distance) and `phi` (singing rate):

1. `M00` as null model $M_{00}$,
2. `Ml0` as phylogeny-only model $M_{\lambda0}$,
3. `M0b` as trait-only model $M_{0\beta}$,
4. `Mlb` as combined model $M_{\lambda\beta}$.

```{r models,eval=FALSE}
met <- "DE" # can use "SANN", "Nelder-Mead" is quickest
x <- lhreg_data
vc <- cor_matrix

## model matrix definitions
X0 <- matrix(1, nrow(x), 1) # null (for both)
colnames(X0) <- "Intercept"
Xt <- model.matrix(mt) # DD
Xp <- model.matrix(mp) # SR

## fit models for tau

tM00 <- lhreg(Y=x$logtau, X=X0, SE=x$logtauSE, V=vc, lambda=0,
    hessian=TRUE, method=met)
tMl0 <- lhreg(Y=x$logtau, X=X0, SE=x$logtauSE, V=vc, lambda=NA,
    hessian=TRUE, method=met)
tM0b <- lhreg(Y=x$logtau, X=Xt, SE=x$logtauSE, V=vc, lambda=0,
    hessian=TRUE, method=met)
tMlb <- lhreg(Y=x$logtau, X=Xt, SE=x$logtauSE, V=vc, lambda=NA,
    hessian=TRUE, method=met)

## fit models for phi

pM00 <- lhreg(Y=x$logphi, X=X0, SE=x$logphiSE, V=vc, lambda=0,
    hessian=TRUE, method=met)
pMl0 <- lhreg(Y=x$logphi, X=X0, SE=x$logphiSE, V=vc, lambda=NA,
    hessian=TRUE, method=met)
pM0b <- lhreg(Y=x$logphi, X=Xp, SE=x$logphiSE, V=vc, lambda=0,
    hessian=TRUE, method=met)
pMlb <- lhreg(Y=x$logphi, X=Xp, SE=x$logphiSE, V=vc, lambda=NA,
    hessian=TRUE, method=met)
```

### Profile likelihood for lambda

Profile likelihood was calculated to understand how traits affect the
strength of phylogeny through the variable `lambda`.
It is possible to use `lambda` > 1 but it leads to extremely low likelihoods
in our case.

```{r profile-lik,eval=FALSE}
## set up lambda values to evaluate at
lam <- seq(0, 1, by=0.01)

## parallel computation is faster
cl <- makeCluster(4)
## load package on workers
tmp <- clusterEvalQ(cl, library(lhreg))

object <- tMl0
clusterExport(cl, "object")
pl_tMl0 <- pbsapply(lam, function(z, ...) profile_lambda1(object, z, ...),
    cl=cl, method=met)

object <- tMlb
clusterExport(cl, "object")
pl_tMlb <- pbsapply(lam, function(z, ...) profile_lambda1(object, z, ...),
    cl=cl, method=met)

object <- pMl0
clusterExport(cl, "object")
pl_pMl0 <- pbsapply(lam, function(z, ...) profile_lambda1(object, z, ...),
    cl=cl, method=met)

object <- pMlb
clusterExport(cl, "object")
pl_pMlb <- pbsapply(lam, function(z, ...) profile_lambda1(object, z, ...),
    cl=cl, method=met)

stopCluster(cl) # close cluster
```

### Leave-one-out (LOO) analysis

Leave one out cross-validation was used to see how well we could predict
the values based on data from the other species, traits and phylogeny.
Mean squared error (MSE) and variance components were calculated based on LOO
cross validation. We also used LOO to calculate jackknife type
nonparametric confidence intervals for the estimated parameters.

```{r loo,eval=FALSE}
## makes sense to use lm for EDR LOO, much quicker
## but we need the full model for LOO based CIs so it doesn't matter
#tM00$coef
#c(coef(mt0), log(summary(mt0)$sigma))
#tM0b$coef
#c(coef(mt), log(summary(mt)$sigma))

#pM00$coef
#c(coef(mp0), log(summary(mp0)$sigma))
#pM0b$coef
#c(coef(mp), log(summary(mp)$sigma))

n <- nrow(x) # we will do n runs

cl <- makeCluster(4) # parallel if you wish
tmp <- clusterEvalQ(cl, library(lhreg)) # load package

#loo_tM00 <- t(pbsapply(1:n, loo1, object=tM00, cl=cl))
loo_tM00 <- t(pbsapply(1:n, loo2, object=tM00, cl=cl, method=met))
loo_tMl0 <- t(pbsapply(1:n, loo2, object=tMl0, cl=cl, method=met))
#loo_tM0b <- t(pbsapply(1:n, loo1, object=tM0b, cl=cl))
loo_tM0b <- t(pbsapply(1:n, loo2, object=tM0b, cl=cl, method=met))
loo_tMlb <- t(pbsapply(1:n, loo2, object=tMlb, cl=cl, method=met))

#loo_pM00 <- t(pbsapply(1:n, loo1, object=pM00, cl=cl))
loo_pM00 <- t(pbsapply(1:n, loo2, object=pM00, cl=cl, method=met))
loo_pMl0 <- t(pbsapply(1:n, loo2, object=pMl0, cl=cl, method=met))
#loo_pM0b <- t(pbsapply(1:n, loo1, object=pM0b, cl=cl))
loo_pM0b <- t(pbsapply(1:n, loo2, object=pM0b, cl=cl, method=met))
loo_pMlb <- t(pbsapply(1:n, loo2, object=pMlb, cl=cl, method=met))

stopCluster(cl)
```

Save the results:

```{r save,eval=FALSE}
save(list=c("cor_matrix", "lam", "lhreg_data", "met", "n",
    "vc", "x", "X0", "Xp", "Xt",
    "amp", "mp", "mp0", "mpx", "mpx2",
    "amt", "mt", "mt0", "mtx", "mtx2",
    "pM00", "pM0b", "pMl0", "pMlb",
    "tM00", "tM0b", "tMl0", "tMlb",
    "pl_pMl0", "pl_pMlb", "pl_tMl0", "pl_tMlb",
    "loo_pM00", "loo_pM0b", "loo_pMl0", "loo_pMlb",
    "loo_tM00", "loo_tM0b", "loo_tMl0", "loo_tMlb"),
    file="~/repos/lhreg/inst/extdata/lhreg-results-DE2.rda")
#    file="lhreg-results-DE2.rda")
```

## Results

Load results and set some values:

```{r load-results}
library(lhreg)
#load(system.file("extdata", "lhreg-results-DE.rda", package = "lhreg"))
#load(system.file("extdata", "lhreg-results-DE2.rda", package = "lhreg"))
load("~/repos/lhreg/inst/extdata/lhreg-results-DE2.rda")

## AIC tables
aict <- AIC(tM00, tMl0, tM0b, tMlb)
aict$dAIC <- aict$AIC-min(aict$AIC)

aicp <- AIC(pM00, pMl0, pM0b, pMlb)
aicp$dAIC <- aicp$AIC-min(aicp$AIC)

cbind(aict, t(sapply(list(tM00, tMl0, tM0b, tMlb),
    function(z) z$summary[c("sigma","lambda"), 1])))

cbind(aicp, t(sapply(list(pM00, pMl0, pM0b, pMlb),
    function(z) z$summary[c("sigma","lambda"), 1])))

## MSE
SSEt <- c(
    tM00 = sum((loo_tM00[,"pred"] - tM00$Y)^2),
    tMl0 = sum((loo_tMl0[,"pred"] - tMl0$Y)^2),
    tM0b = sum((loo_tM0b[,"pred"] - tM0b$Y)^2),
    tMlb = sum((loo_tMlb[,"pred"] - tMlb$Y)^2))
SSEp <- c(
    pM00 = sum((loo_pM00[,"pred"] - pM00$Y)^2),
    pMl0 = sum((loo_pMl0[,"pred"] - pMl0$Y)^2),
    pM0b = sum((loo_pM0b[,"pred"] - pM0b$Y)^2),
    pMlb = sum((loo_pMlb[,"pred"] - pMlb$Y)^2))
MSEt <- SSEt / n
MSEp <- SSEp / n

Level <- 0.95
Crit <- -0.5*qchisq(Level, 1)
ltmp <- seq(0, 1, by=0.0001)
## red-yl-blue
Col <- c("#2C7BB6", "#6BAACF", "#ABD9E9", "#D4ECD3", "#FFFFBF", "#FED690",
    "#FDAE61", "#EA633E", "#D7191C")
Col1 <- Col[1]
Col2 <- rgb(171/255, 217/255, 233/255, 0.5) # Col[3]
Col3 <- Col[9]
Col4 <- rgb(253/255, 174/255, 97/255, 0.5) # Col[7]
prt <- exp(loo_tM0b[,1:2])
prp <- exp(loo_pMlb[,1:2])
```

### Table with estimates and MSE

```{r table-1}
sf <- function(z, loo, wald=TRUE, level=0.95) {
    zz <- z$summary
    a <- c((1-level)/2, 1-(1-level)/2)
    CI <- t(apply(rbind(zz[,1], loo[,3:ncol(loo),drop=FALSE]), 2, quantile, a))
    if (wald) {
        pcut <- function(p) {
            factor(c("***", "**", "*", "+", "ns")[as.integer(cut(p,
                c(1, 0.1, 0.05, 0.01, 0.001, 0),
                include.lowest=TRUE, right=FALSE))],
                levels=c("***", "**", "*", "+", "ns"))
        }
        out <- structure(sapply(1:nrow(zz), function(i)
            paste0(round(zz[i,1], 3), " (SE +/- ", round(zz[i,2], 3),
            pcut(zz[i,4]), ")")), names=rownames(zz))
    } else {
        out <- structure(sapply(1:nrow(zz), function(i)
            paste0(round(zz[i,1], 3), " (", round(CI[i,1], 3), ", ",
            round(CI[i,2], 3), ")")), names=rownames(zz))
    }
    out
}
Wald <- FALSE
zzz <- list(
    M00=sf(pM00, loo_pM00, Wald, Level),
    Ml0=sf(pMl0, loo_pMl0, Wald, Level),
    M0b=sf(pM0b, loo_pM0b, Wald, Level),
    Mlb=sf(pMlb, loo_pMlb, Wald, Level))
m <- matrix("", length(zzz[[4]]), 4)
rownames(m) <- names(zzz[[4]])
colnames(m) <- c("M00", "Ml0", "M0b", "Mlb")
for (i in 1:4) {
    j <- match(names(zzz[[i]]), rownames(m))
    m[j,i] <- zzz[[i]]
}
m["lambda", c("M00", "M0b")] <- "0 (fixed)"
#m[m==""] <- "n/a"
m1 <- m

zzz <- list(
    M00=sf(tM00, loo_tM00, Wald, Level),
    Ml0=sf(tMl0, loo_tMl0, Wald, Level),
    M0b=sf(tM0b, loo_tM0b, Wald, Level),
    Mlb=sf(tMlb, loo_tMlb, Wald, Level))
m <- matrix("", length(zzz[[4]]), 4)
rownames(m) <- names(zzz[[4]])
colnames(m) <- c("M00", "Ml0", "M0b", "Mlb")
for (i in 1:4) {
    j <- match(names(zzz[[i]]), rownames(m))
    m[j,i] <- zzz[[i]]
}
m["lambda", c("M00", "M0b")] <- "0 (fixed)"
#m[m==""] <- "n/a"
m2 <- m

m1 <- rbind(m1, df=aicp$df, dAIC=round(aicp$dAIC, 3),
    XV_MSE=round(MSEp, 3))
m2 <- rbind(m2, df=aict$df, dAIC=round(aict$dAIC, 3),
    XV_MSE=round(MSEt, 3))

print.default(m1, quote=FALSE) # SR results
print.default(m2, quote=FALSE) # DD results
```

### Tree with SR and DD values

We hack the `phytools::contMap` function to produce non-rainbow colors:

```{r tree-trait,fig.height=12,fig.width=12}
library(phytools)

contMap2 <-
function (tree, x, res = 100, fsize = NULL, ftype = NULL, lwd = 4,
    legend = NULL, lims = NULL, outline = TRUE, sig = 3, type = "phylogram",
    direction = "rightwards", plot = TRUE, col_fun=rainbow, ...)
{
    if (!inherits(tree, "phylo"))
        stop("tree should be an object of class \"phylo\".")
    if (hasArg(mar))
        mar <- list(...)$mar
    else mar <- rep(0.3, 4)
    if (hasArg(offset))
        offset <- list(...)$offset
    else offset <- NULL
    if (hasArg(method))
        method <- list(...)$method
    else method <- "fastAnc"
    if (hasArg(hold))
        hold <- list(...)$hold
    else hold <- TRUE
    if (hasArg(leg.txt))
        leg.txt <- list(...)$leg.txt
    else leg.txt <- "trait value"
    h <- max(nodeHeights(tree))
    steps <- 0:res/res * max(h)
    H <- nodeHeights(tree)
    if (method == "fastAnc")
        a <- fastAnc(tree, x)
    else if (method == "anc.ML") {
        fit <- anc.ML(tree, x)
        a <- fit$ace
        if (!is.null(fit$missing.x))
            x <- c(x, fit$missing.x)
    }
    else if (method == "user") {
        if (hasArg(anc.states))
            anc.states <- list(...)$anc.states
        else {
            cat("No ancestral states have been provided. Using states estimated with fastAnc.\n\n")
            a <- fastAnc(tree, x)
        }
        if (length(anc.states) < tree$Nnode) {
            nodes <- as.numeric(names(anc.states))
            tt <- tree
            for (i in 1:length(nodes)) {
                M <- matchNodes(tt, tree, method = "distances")
                ii <- M[which(M[, 2] == nodes[i]), 1]
                tt <- bind.tip(tt, nodes[i], edge.length = 0,
                  where = ii)
            }
            a <- fastAnc(tt, c(x, anc.states))
            M <- matchNodes(tree, tt, method = "distances")
            a <- a[as.character(M[, 2])]
            names(a) <- M[, 1]
        }
        else {
            if (is.null(names(anc.states)))
                names(anc.states) <- 1:tree$Nnode + Ntip(tree)
            a <- anc.states[as.character(1:tree$Nnode + Ntip(tree))]
        }
    }
    y <- c(a, x[tree$tip.label])
    names(y)[1:Ntip(tree) + tree$Nnode] <- 1:Ntip(tree)
    A <- matrix(y[as.character(tree$edge)], nrow(tree$edge),
        ncol(tree$edge))
    cols <- col_fun(1001)
    names(cols) <- 0:1000
    if (is.null(lims))
        lims <- c(min(y), max(y))
    trans <- 0:1000/1000 * (lims[2] - lims[1]) + lims[1]
    names(trans) <- 0:1000
    tree$maps <- vector(mode = "list", length = nrow(tree$edge))
    for (i in 1:nrow(tree$edge)) {
        XX <- cbind(c(H[i, 1], steps[intersect(which(steps >
            H[i, 1]), which(steps < H[i, 2]))]), c(steps[intersect(which(steps >
            H[i, 1]), which(steps < H[i, 2]))], H[i, 2])) - H[i,
            1]
        YY <- rowMeans(XX)
        if (!all(YY == 0)) {
            b <- vector()
            for (j in 1:length(YY)) b[j] <- (A[i, 1]/YY[j] +
                A[i, 2]/(max(XX) - YY[j]))/(1/YY[j] + 1/(max(XX) -
                YY[j]))
        }
        else b <- A[i, 1]
        d <- sapply(b, phytools:::getState, trans = trans)
        tree$maps[[i]] <- XX[, 2] - XX[, 1]
        names(tree$maps[[i]]) <- d
    }
    tree$mapped.edge <- phytools:::makeMappedEdge(tree$edge, tree$maps)
    tree$mapped.edge <- tree$mapped.edge[, order(as.numeric(colnames(tree$mapped.edge)))]
    class(tree) <- c("simmap", setdiff(class(tree), "simmap"))
    xx <- list(tree = tree, cols = cols, lims = lims)
    class(xx) <- "contMap"
    if (plot)
        phytools:::plot.contMap(xx, fsize = fsize, ftype = ftype, lwd = lwd,
            legend = legend, outline = outline, sig = sig, type = type,
            mar = mar, direction = direction, offset = offset,
            hold = hold, leg.txt = leg.txt)
    invisible(xx)
}

library(ape)
#load(system.file("extdata", "mph.rda", package = "lhreg"))
load("~/repos/lhreg/inst/extdata/mph.rda")
length(mph)
tre <- mph[[1000]] # pick one tree

ii <- match(tre$tip.label, rownames(lhreg_data))
NAMES <- as.character(lhreg_data$common_name)[ii]
tre$tip.label <- NAMES
PHI <- structure(exp(lhreg_data$logphi)[ii], .Names=NAMES)
TAU <- 100*structure(exp(lhreg_data$logtau)[ii], .Names=NAMES)

col_fun <- colorRampPalette(Col) # red-yl-blue

pdf("FigX.pdf", width=10, height=10)

op <- par(mfrow=c(1,2))
contMap2(tre, PHI,
    fsize=0.4, outline=FALSE, col_fun=col_fun, main="SR", lwd=2)
contMap2(tre, TAU,
    fsize=0.4, outline=FALSE, col_fun=col_fun, direction="leftwards",
    main="DD", lwd=2)
par(op)

dev.off()
```

### Profile likelihood figures

```{r fig-1,width=14,height=6}
#pdf("Fig1.pdf", width=14, height=6)
op <- par(mfrow=c(1,2))

Res1 <- pl_pMl0
Res2 <- pl_pMlb
yv <- exp(Res1-max(Res1))
plot(lam, yv, type="n", lwd=1, ylim=exp(c(2*Crit, 0)),
    xlab=expression(lambda), ylab="Profile Likelihood Ratio")
tmp1 <- splinefun(lam, yv)(ltmp)
i1 <- tmp1 > exp(Crit)
yv <- exp(Res2-max(Res2))
tmp2 <- splinefun(lam, yv)(ltmp)
i2 <- tmp2 > exp(Crit)
polygon(c(ltmp[i1], rev(ltmp[i1])),
    c(tmp1[i1], rep(-1, sum(i1))),
    col=Col2, border=NA)
polygon(c(ltmp[i2], rev(ltmp[i2])),
    c(tmp2[i2], rep(-1, sum(i2))),
    col=Col4, border=NA)
abline(h=exp(Crit), col="grey")
lines(ltmp, tmp1, col=Col1, lwd=1)
lines(ltmp[i1], tmp1[i1], col=Col1, lwd=3)
lines(rep(ltmp[which.max(tmp1)], 2), c(1, -1), col=Col1)
lines(ltmp, tmp2, col=Col3, lwd=1)
lines(ltmp[i2], tmp2[i2], col=Col3, lwd=3)
lines(rep(ltmp[which.max(tmp2)], 2), c(1, -1), col=Col3)
box()
legend(0.1, 1, bty="n", border=c(Col1, Col3), fill=c(Col2, Col4), pt.cex=2, pt.lwd=2,
    legend=c(expression(M[lambda*0]-SR), expression(M[lambda*beta]-SR)))
round(c(Max_Ml0=ltmp[which.max(tmp1)], CI=range(ltmp[i1])), 3)
round(c(Max_Mlx=ltmp[which.max(tmp2)], CI=range(ltmp[i2])), 3)

Res1 <- pl_tMl0
Res2 <- pl_tMlb
yv <- exp(Res1-max(Res1))
plot(lam, yv, type="n", lwd=1, ylim=exp(c(2*Crit, 0)),
    xlab=expression(lambda), ylab="Profile Likelihood Ratio")
tmp1 <- splinefun(lam, yv)(ltmp)
i1 <- tmp1 > exp(Crit)
yv <- exp(Res2-max(Res2))
tmp2 <- splinefun(lam, yv)(ltmp)
i2 <- tmp2 > exp(Crit)
polygon(c(ltmp[i1], rev(ltmp[i1])),
    c(tmp1[i1], rep(-1, sum(i1))),
    col=Col2, border=NA)
polygon(c(ltmp[i2], rev(ltmp[i2])),
    c(tmp2[i2], rep(-1, sum(i2))),
    col=Col4, border=NA)
abline(h=exp(Crit), col="grey")
lines(ltmp, tmp1, col=Col1, lwd=1)
lines(ltmp[i1], tmp1[i1], col=Col1, lwd=3)
lines(rep(ltmp[which.max(tmp1)], 2), c(1, -1), col=Col1)
lines(ltmp, tmp2, col=Col3, lwd=1)
lines(ltmp[i2], tmp2[i2], col=Col3, lwd=3)
lines(rep(ltmp[which.max(tmp2)], 2), c(1, -1), col=Col3)
box()
legend(0.1, 1, bty="n", border=c(Col1, Col3), fill=c(Col2, Col4), pt.cex=2, pt.lwd=2,
    legend=c(expression(M[lambda*0]-DD), expression(M[lambda*beta]-DD)))
round(c(Max_Ml0=ltmp[which.max(tmp1)], CI=range(ltmp[i1])), 3)
round(c(Max_Mlx=ltmp[which.max(tmp2)], CI=range(ltmp[i2])), 3)

par(op)

#dev.off()
```

### LOO cross validation plots

Need to label outliers
Need to add better legend for continuous (nested circles)

```{r fig-2,width=14,height=7}
#pdf("Fig2.pdf", width=14, height=7)

op <- par(mfrow=c(1,2))

Max <- 0.7
plot(prp, xaxs = "i", yaxs = "i", type="n",
    ylim=c(0, Max), xlim=c(0, Max),
    xlab="Time-removal SR Estimate", ylab="LOO SR Estimate")
abline(0,1,lty=1, col=1)
abline(0,2,lty=2, col="grey")
abline(0,1/2,lty=2, col="grey")
abline(0,1.5,lty=2, col="grey")
abline(0,1/1.5,lty=2, col="grey")
points(prp, xaxs = "i", yaxs = "i",
    col=c(Col1,Col3)[as.integer(x$Mig2)],
    cex=0.2+2*x$MaxFreqkHz/10)
box()
legend("topleft", pch=21, col=c(Col1,Col3,1,1),
    pt.cex=c(1.5,1.5,2,1), bty="n",
    legend=c("Migrant", "Resident", "Song Picth: High", "Song Pitch: Low"))
text(0.9*Max, 0.05*Max, expression(M[lambda*beta]-SR))

Max <- 2.1
plot(prt, xaxs = "i", yaxs = "i", type="n",
    ylim=c(0, Max), xlim=c(0, Max),
    xlab="Distance-sampling DD Estimate", ylab="LOO DD Estimate")
abline(0,1,lty=1, col=1)
abline(0,2,lty=2, col="grey")
abline(0,1/2,lty=2, col="grey")
abline(0,1.5,lty=2, col="grey")
abline(0,1/1.5,lty=2, col="grey")
points(prt, xaxs = "i", yaxs = "i",
    cex=0.2+2*x$logmass/5,
    col=c(Col1,Col3)[as.integer(x$Hab2)])
box()
legend("topleft", pch=21, col=c(Col1,Col3,1,1), pt.cex=c(1.5,1.5,2,1), bty="n",
    legend=c("Habitat: Closed", "Habitat: Open", "Body Mass: Large", "Body Mass: Small"))
text(0.9*Max, 0.05*Max, expression(M[0*beta]-DD))

par(op)

#dev.off()
```

